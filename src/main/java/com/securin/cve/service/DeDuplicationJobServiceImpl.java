package com.securin.cve.service;

import com.securin.cve.entity.CveData;
import com.securin.cve.entity.DeDupDataHold;
import com.securin.cve.repo.CveDataRepository;
import com.securin.cve.repo.DeDupDataHoldRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.Resource;
import org.springframework.dao.DataAccessException;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.CopyOnWriteArrayList;

@Service
@RequiredArgsConstructor
@Slf4j
public class DeDuplicationJobServiceImpl implements DeDuplicationJobService {

    private final CveDataRepository cveDataRepository;

    private final DeDupDataHoldRepository deDupDataHoldRepository;

    @Value("classpath:commonWords.txt")
    Resource resourceFile;

    @Override
    public void runJob() {
        var lastModifiedDate = LocalDateTime.of(1990,1,1,0,0);//getLastModifiedDate();
        int startIndex = 0;
        while (true) {
            var cveDataList = getAllCveDataByLastModifiedDate(lastModifiedDate, startIndex);
            if (cveDataList.isEmpty()) {
                break;
            }
            List<DeDupDataHold> deDupDataHoldList = convertCveDataListToDeDupHoldList(cveDataList);
            CopyOnWriteArrayList<CveData> modifiedList = new CopyOnWriteArrayList<>(cveDataList);
            removeDescriptionLessDataFromCveData(deDupDataHoldList, modifiedList);
            List<String> duplicateCveIds = saveAndReturnDuplicateDataToCollection(deDupDataHoldList);
            removeDuplicateRecords(duplicateCveIds);
            startIndex = startIndex + 1;
        }
    }

    public void removeDuplicateRecords(List<String> duplicateCveIds) {
        try {
            cveDataRepository.deleteAllById(duplicateCveIds);
        } catch (DataAccessException e) {
            log.error("Exception occurred while deleting records from cve_data");
        }
    }

    private List<String> saveAndReturnDuplicateDataToCollection(List<DeDupDataHold> deDupDataHoldList) {
        List<String> duplicates = new ArrayList<>();
        for (var deDupDataHold : deDupDataHoldList) {
            var isExists = deDupDataHoldRepository.existsById(deDupDataHold.getCveDescription());
            if (isExists) {
                duplicates.add(deDupDataHold.getCveId());
            }
            deDupDataHoldRepository.save(deDupDataHold);
        }
        return duplicates;
    }

    private void removeDescriptionLessDataFromCveData(List<DeDupDataHold> deDupDataHoldList, CopyOnWriteArrayList<CveData> cveDataList) {
        for (var deDupDataHold : deDupDataHoldList) {
            cveDataList.removeIf(cveData -> cveData.getId().equals(deDupDataHold.getCveId()));
        }
        try {
            cveDataRepository.deleteAll(cveDataList);
        } catch (DataAccessException e) {
            log.error("Exception occurred while deleting records from cve_data");
        }
    }

    public LocalDateTime getLastModifiedDate() {
        var deDupDataHoldOpt = deDupDataHoldRepository.findTopByOrderByLastModifiedDateDesc();
        return deDupDataHoldOpt.orElse(DeDupDataHold.builder().lastModifiedDate(LocalDateTime.of(1900,1,1,0,0)).build()).getLastModifiedDate();
    }

    public List<CveData> getAllCveDataByLastModifiedDate(LocalDateTime lastModifiedDate, int startIndex) {
        return cveDataRepository.findAllByLastModifiedAfter(lastModifiedDate, PageRequest.of(startIndex, 200, Sort.by("lastModified")));
    }

    public List<DeDupDataHold> convertCveDataListToDeDupHoldList(List<CveData> cveDataList) {
        return cveDataList.stream().map(cveData -> {
            List<Map<String, String>> descriptions = cveData.getDescriptions();
            if (!descriptions.isEmpty()) {
                for (Map<String, String> description : descriptions) {
                    if (description.containsKey("lang") && description.get("lang").equals("en")) {
                        var shortDesc = convertToShorthandDescription(description.get("value"));
                        return DeDupDataHold.builder().cveId(cveData.getId()).cveDescription(shortDesc).lastModifiedDate(cveData.getLastModified()).build();
                    }
                }
                var shortDesc = convertToShorthandDescription(descriptions.get(0).get("value"));
                return DeDupDataHold.builder().cveId(cveData.getId()).cveDescription(shortDesc).lastModifiedDate(cveData.getLastModified()).build();
            }
            return null;
        }).filter(Objects::nonNull).toList();
    }

    public String convertToShorthandDescription(String description) {
        String shorthandDescription = description.toLowerCase();
        try {
            Path path = Path.of(resourceFile.getURI());
            var fileContent = Files.readAllLines(path);
            var initialSpace = "";
            for (String word : fileContent) {
                shorthandDescription = shorthandDescription.replaceAll(initialSpace + word + " ", " ");
                initialSpace = " ";
            }
        } catch (IOException e) {
            log.error("Exception while reading the file for deduplication job");
        }
        return shorthandDescription.strip();
    }

}
