package com.securin.cve.service;

import com.securin.cve.client.NvdClient;
import com.securin.cve.entity.BatchMetaData;
import com.securin.cve.entity.CveData;
import com.securin.cve.model.NvdClientResponse;
import com.securin.cve.repo.BatchMetaDataRepository;
import com.securin.cve.utils.CveMapper;
import jakarta.annotation.PostConstruct;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.dao.DataAccessException;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Objects;

import static com.securin.cve.utils.CveConstants.*;

@Service
@RequiredArgsConstructor
@Slf4j
public class OneTimeFullDataMigrationServiceImpl implements OneTimeFullDataMigrationService{

    private final NvdClient nvdClient;

    private final BatchMetaDataRepository batchMetaDataRepository;

    private final CveService cveService;

    private final CveMapper cveMapper;

    @Override
    public void runJob() {
        Long startIndex = getStartingIndexForFullRunJob();
        log.info("One time job started from start index {}", startIndex);
        Long resultsPerPage = RESULTS_PER_PAGE;
        long updateIndex = 0L;
        Long totalResult = 0L;
        try {
            while (resultsPerPage >= RESULTS_PER_PAGE) {
                NvdClientResponse nvdClientResponse = getNvdDataFromStartToEndIndex(startIndex, resultsPerPage, 0);
                if (nvdClientResponse != null) {
                    List<CveData> cveDataList = cveMapper.mapNvdResponseToCveDataList(nvdClientResponse);
                    cveService.saveCveDataToCveCollection(cveDataList);
                    Thread.sleep(6000);
                    resultsPerPage = nvdClientResponse.getResultsPerPage();
                    totalResult = nvdClientResponse.getTotalResults();
                    startIndex += resultsPerPage;
                    updateIndex += 1;
                    if (updateIndex % 5 == 0) {
                        updateStartIndexToCollection(startIndex, JOB_RUNNING_STATUS);
                    }
                } else {
                    log.error("NULL response from nvd client. Onetime job failed!!");
                    break;
                }
            }
            if (Objects.equals(startIndex, totalResult)) {
                updateStartIndexToCollection(startIndex, JOB_COMPLETED_STATUS);
            }
            log.info("One time successfully completed!!!");
        }
        catch (InterruptedException e) {
            log.info("Interruption occurred while running one time job, hence job failed!!", e);
        }
    }

    public Long getStartingIndexForFullRunJob() {
        var batchMetaDataOpt = batchMetaDataRepository.findById(1);
        return batchMetaDataOpt.orElse(BatchMetaData.builder().startIndex(0L).build()).getStartIndex();
    }

    private NvdClientResponse getNvdDataFromStartToEndIndex(Long startIndex, Long resultPerPage, int noOfTry) throws InterruptedException {
        if (noOfTry < 3) {
            ResponseEntity<NvdClientResponse> nvdResponse = nvdClient.getCveDataByResultsPerPageAndStartIndex(resultPerPage, startIndex);
            if (nvdResponse.getStatusCode().is2xxSuccessful()) {
                return nvdResponse.getBody();
            } else {
                Thread.sleep(6000);
                return getNvdDataFromStartToEndIndex(startIndex, resultPerPage, noOfTry + 1);
            }
        }
        return null;
    }

    public void updateStartIndexToCollection(Long startIndex, String jobStatus) {
        try {
            batchMetaDataRepository.save(BatchMetaData.builder().id(1)
                    .startIndex(startIndex)
                    .jobStatus(jobStatus).build());
        }
        catch (DataAccessException e){
            log.error("Exception occurred while updating {} status", jobStatus, e);
        }
    }

}
